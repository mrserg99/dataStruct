package setarray;// Реализация АТД множества на векторах

import java.util.NoSuchElementException;
import def.MySet;

public class SetArray implements MySet {

    int[] set; // наш массив элементов
    private final int min; // левая граница диапазона
    private final int max; // правая граница диапазона
    // Смещение начала множества относительно глобального нуля
    private final int zeroIndex;

    public SetArray(int min, int max) {
        // задаём границы диапазона min и max
        this.min = min;
        this.max = max;

        // вычисляем размер массива, который нужно создать и наше смещение относительно глобального нуля(zeroIndex)
        int size;
        //Если у нас левая граница меньше нуля, то
        if (min < 0) {
            size = max / 32 - (min + 1) / 32 + 2;
            zeroIndex = -((min + 1) / 32) + 1;
        }
        //Иначе если левая граница больше или равна нулю, то
        else {
            size = max / 32 - min / 32 + 1;
            zeroIndex = -(min / 32);
        }

        //Создаём массив длинна которого равна найденной нами длине
        set = new int[size];

    }

    private void copyFrom(SetArray B) {
        for (int i = 0; i < this.set.length; i++) {
            this.set[i] = B.set[i];
        }
    }

    //Проверка на пересечение множеств
    private boolean isIntersection(SetArray B) {
        if (this.min > B.max || this.max < B.min)
            return false;

        int len = Math.min(this.max, B.max) / 32 - Math.max(this.min, B.min) / 32 + 1;
        int shift = Math.abs(this.zeroIndex - B.zeroIndex);

        if (this.zeroIndex < B.zeroIndex) {
            for (int i = 0; i < len; i++)
                if ((set[i] & B.set[i + shift]) != 0)
                    return true;
        } else {
            for (int i = 0; i < len; i++)
                if ((set[i + shift] & B.set[i]) != 0)
                    return true;
        }

        return false;
    }

    // побитовый сдвиг, чтобы преобразовать число в биты
    private int getShift(int x) {
        //Если Х больше или равен 0, то битого сдвинем единицу на число равное (31 - x % 32)
        if (x >= 0)
            return 1 << (31 - x % 32);

            //Иначе битого сдвинем единицу на число равное (-(x + 1) % 32)
        else
            return 1 << -(x + 1) % 32;
    }

    // позиция числа как битовой единицы в диапазоне
    private int getPosition(int x) {
        //Если Х меньше чем ноль, то позиция будет определяться как (x + 1) / 32 - 1

        int pos;
        if (x < 0)
            pos = (x + 1) / 32 - 1;
            //Иначе позиция будет определяться как x / 32
        else
            pos = x / 32;
        return pos;

    }

    public void print() {
        boolean firstValue = true;
        System.out.print("{");
        for (int i = min; i <= max; i++) {
            if (member(i)) {
                if(!firstValue) {
                    System.out.print(", ");
                }
                firstValue = false;
                System.out.print(i);
            }
        }
        System.out.print("}\n");
    }

    @Override
    // объединение множества А с множеством В
    public MySet union(MySet b) {
        //Для того чтобы создать новое множество, в которое мы запишем результат, нам нужно:
        //1) Вычисляем самую минимальную границу из minA и minB и это будет наш minC
        int minC = Math.min(this.min, ((SetArray) b).min);
        //2) Вычисляем самую максимальную границу из maxA и maxB и это будет наш maxC
        int maxC = Math.max(this.max, ((SetArray) b).max);

        //Зададим новую переменную C класса Set с только что найденными границами(minC, maxC)
        SetArray C = new SetArray(minC, maxC);

        /*Далее нам нужно определить смещение множество С относительно множества А, и смещение множества С относительно множества В
        Это нужно нам, чтобы определить в какую ячейку множества С нужно занести, например, значение первой ячейки множества В*/

        //Вычисляем смещение множества А относительно множества С.
        //Находим модуль разности А.zeroIndex и С.zeroIndex
        int shiftA = Math.abs(this.zeroIndex - C.zeroIndex);

        //Вычисляем смещение множества В относительно множества С.
        //Находим модуль разности В.zeroIndex и С.zeroIndex
        int shiftB = Math.abs(((SetArray) b).zeroIndex - C.zeroIndex);

        /*Пройдёмся по элементам множеств А и B в цикле, который будет длиться пока не закончится какое-то из множеств.
        В цикле используя найденное нами смещение будем заносить значения ячеек из множества А и множества B во множество С, используя побитовое ИЛИ.*/
        int i;
        for (i = 0; i < this.set.length && i < ((SetArray) b).set.length; i++) {
            C.set[i + shiftA] |= this.set[i];
            C.set[i + shiftB] |= ((SetArray) b).set[i];
        }
        //После завершения цикла нужно проверить, какое из множеств закончилось.
        //Если закончились оба множества, то возвращаем С
        if (i == this.set.length && i == ((SetArray) b).set.length) return C;

            //Если закончилось множество А, то мы в цикле заносим оставшиеся значения множества В в множество С
        else if (i == this.set.length) {
            for (int j = i; j < ((SetArray) b).set.length; j++) {
                C.set[j + shiftB] |= ((SetArray) b).set[j];
            }
        }
        //Если закончилось множество В, то мы в цикле заносим оставшиеся значения множества А в множество С
        else if (i == ((SetArray) b).set.length) {
            for (int j = i; j < this.set.length; j++) {
                C.set[j + shiftA] |= this.set[j];
            }
        }
        //Возвращаем результат С
        return C;
    }

    @Override
    // пересечение множества А с множеством В
    public MySet intersection(MySet b) {
        /*Если левая граница множества А больше правой границы множества В
		или правая граница множества А меньше чем левая граница множества В
		то значит множества не пересекаются и нет смысла искать пересечение.
		Возвращаем пустое множество.*/
        if (this.min > ((SetArray) b).max || this.max < ((SetArray) b).min) return null;

        //Для того чтобы создать новое множество, в которое мы запишем результат, нам нужно:
        //Вычислим границы нового множества-результата С:
        //    a) Нужно найти максимальную левую границу из minA и minB это будет наш minC;
        int minC = Math.max(this.min, ((SetArray) b).min);
        //    b) Так же найти минимальную правую границу из maxA и maxB это будет наш maxC.
        int maxC = Math.min(this.max, ((SetArray) b).max);

        //Используя новые границы (minC, maxC) зададим новую переменную C класса Set
        SetArray C = new SetArray(minC, maxC);

	    /*Далее нам нужно определить смещение множество С относительно множества А, и смещение множества С относительно множества В.
    	  Это нужно нам, чтобы определить в какую ячейку множества С нужно занести, например, значение первой ячейки множества В.*/

        //Вычисляем смещение множества А относительно множества С.
        // Находим модуль разности А.zeroIndex и С.zeroIndex
        int shiftA = Math.abs(this.zeroIndex - C.zeroIndex);

        //Вычисляем смещение множества В относительно множества С.
        // Находим модуль разности В.zeroIndex и С.zeroIndex
        int shiftB = Math.abs(((SetArray) b).zeroIndex - C.zeroIndex);

        //Пройдёмся по элементам множества А и B в цикле, который будет длиться ровно(длинна массива в множестве С) итераций
        for (int i = 0; i < C.set.length; i++) {
            //В цикле, используя найденное нами смещение, будем заносить значения ячеек из множества А и B во множество С, используя обычное приравнивание и логическое умножение.
            C.set[i] = this.set[i + shiftA];
            C.set[i] &= ((SetArray) b).set[i + shiftB];
        }

        // Возвращаем множество С
        return C;
    }

    @Override
    // разность множества А с множеством В
    public MySet difference(MySet b) {
        // Выполним проверку:
		/*Если левая граница множества А больше левой границы множества В
		и правая граница множества А меньше чем правая граница множества В
		то значит множество А полностью лежит в множестве В и нет смысла искать разность. Возвращаем null.*/
        if (this.min > ((SetArray) b).min && this.max < ((SetArray) b).max) {
            return null;
        }

        /*Если правая граница множества А меньше чем левая граница множества В
		или левая граница множества А больше чем правая граница множества В, то
		множество А полностью лежит вне множество В, тогда ответом будет все значения, которые лежат
		в множестве А. Скопируем множество А в новое множество С и вернём С как результат*/
        if (this.max < ((SetArray) b).min || this.min > ((SetArray) b).max) {
            SetArray C = new SetArray(this.min, this.max);
            C.copyFrom(this);
            return C;
        }


        //Границами будущего нового множества C будут границы множества А.
        //С этими границами (minA, maxA) зададим новую переменную C класса Set
        SetArray C = new SetArray(this.min, this.max);
        // Скопируем все элементы А в С
        C.copyFrom(this);

        /*Далее нам нужно определить смещение множества С относительно множества В.
            Это нужно нам, чтобы определить из какой ячейки множества С нужно удалить значение ячейки В, которое пересекается с ячейкой А.*/

        //Вычисляем смещение множества В относительно множества С.
        //Находим модуль разности В.zeroIndex и С.zeroIndex

        int shift = Math.abs(this.zeroIndex - ((SetArray) b).zeroIndex);


        if (this.zeroIndex >= ((SetArray) b).zeroIndex) {
            for (int i = 0; (i + shift) < C.set.length && i < ((SetArray) b).set.length; i++) {
                C.set[i + shift] &= ~((SetArray) b).set[i];
            }
        } else {
            for (int i = 0; i < C.set.length && (i + shift) < ((SetArray) b).set.length; i++) {
                C.set[i] &= ~((SetArray) b).set[i + shift];
            }
        }

        return C;
    }

    @Override
    // слияние множества А с множеством В
    public MySet merge(MySet b) {
        //Проверим не пересекаются ли множества. Если множества пересекаются, то возвращаем null
        if (this.isIntersection(((SetArray) b))) return null;
        //Найдём новые границы для множества.
        //Вычисляем самую минимальную границу из minA и minB это наш minC
        int minC = Math.min(this.min, ((SetArray) b).min);
        //Вычисляем самую максимальную границу из maxA и maxB это наш maxC
        int maxC = Math.max(this.max, ((SetArray) b).max);
        //Используя найденные границы зададим новую переменную C класса Set
        SetArray C = new SetArray(minC, maxC);

        //Далее нам нужно определить смещение множество С относительно множества А, и смещение множества С относительно множества В
        //Это нужно нам, чтобы определить в какую ячейку множества С нужно занести, например, значение первой ячейки множества В

        //Вычисляем смещение множества А относительно множества С.
        //Находим модуль разности А.zeroIndex и С.zeroIndex
        int shiftA = Math.abs(this.zeroIndex - C.zeroIndex);

        //Вычисляем смещение множества В относительно множества С.
        //Находим модуль разности В.zeroIndex и С.zeroIndex
        int shiftB = Math.abs(((SetArray) b).zeroIndex - C.zeroIndex);

        int i;
        //Пройдёмся по элементам множеств А и B в цикле, который будет длиться пока не закончится какое-то из множеств
        for (i = 0; i < this.set.length && i < ((SetArray) b).set.length; i++) {
            //В цикле используя найденное нами смещение будем заносить значения ячеек из множества А и множества B
            //во множество C используя побитовое ИЛИ
            C.set[i + shiftA] |= this.set[i];
            C.set[i + shiftB] |= ((SetArray) b).set[i];
        }

        //После завершения цикла нужно проверить, какое из множеств закончилось.
        //Если закончились оба множества, то возвращаем С
        if (i == this.set.length && i == ((SetArray) b).set.length) return C;

            //Если закончилось множество А, то мы в цикле заносим оставшиеся значения множества B в множество С
        else if (i == this.set.length) {
            for (int j = i; j < ((SetArray) b).set.length; j++) {
                C.set[i + shiftB] |= ((SetArray) b).set[i];
            }
        }
        //Если закончилось множество В, то мы в цикле заносим оставшиеся значения множества А в множество С
        else if (i == ((SetArray) b).set.length) {
            for (int j = i; j < this.set.length; j++) {
                C.set[i + shiftA] |= this.set[i];
            }
        }
        //Возвращаем результат С
        return C;
    }

    @Override
    //  принадлежность атома к множеству
    public boolean member(int x) {
        //Проверим, Если значение Х выходи за границы множества, то возвращаем false
        if (x < this.min || x > this.max) return false;

        //Используя метод getPosition найдём в каком диапазоне должен располагаться данный элемент
        int pos = getPosition(x);

        //Далее мы можем прибавить к найденному значению наш zeroIndex, чтобы обратится к нужному элементу множества
        int b = set[pos + zeroIndex];

        //Преобразуем число Х в битовое представление используя метод getShift
        int converted_number = getShift(x);

        /*Если логическое умножение элемента множества с индексом, который мы нашли,
        и найденного битового представления отлично от нуля, значит множество содержит данный Х, возвращаем true
        Иначе false*/
        return (b & converted_number) != 0;
    }

    @Override
    // делаем множество пустым
    public void makeNull() {
        //Пройдёмся в цикле, который будет длиться пока множество А не закончится.
        for (int i = 0; i < this.set.length; i++) {
            //В цикле мы будем приравнивать элементы массива к нулю
            this.set[i] = 0;
        }
    }

    @Override
    // добавляем атом х в множество А
    public void insert(int x) {
        // Проверим:
        // Если наш Х больше чем правая граница множества А или меньше чем левая граница множества А, то вставлять бессмысленно, делаем return
        if (x < this.min || x > this.max) return;

        /*После проверки необходимо определить в какой диапазон (ячейку массива) нужно вставить наш Х
    	    Для этого используем метод getPosition который вернёт нам индекс элемента массива, куда нужно вставить*/
        int pos = getPosition(x);

    	/*После этого, так как наш Х преобразуется в двоичное число в нормальном виде,
          а нам нужно понять какой бит нам нужно изменить на единицу, нам нужно определить сдвиг этого единичного байта в числе.
          Для этого используем метод getShift который вернёт нам набор битов с единственным единичным битом в нужном месте.*/
        int converted_number = getShift(x);

        /* После нахождения всего необходимого нам остаётся только вставить этот набор битов в соответствующий
         элемент множества А используя при этом побитовое ИЛИ*/
        this.set[pos + this.zeroIndex] |= converted_number;
    }

    @Override
    // удаляем атом х из множества А
    public void delete(int x) {
        // Проверим:
        //Если наш Х больше чем правая граница множества А или меньше чем левая граница множества А, то удалять нечего, делаем return
        if (x > this.max || x < this.min) return;

        //Определим индекс элемента(диапазона) в котором должен находится наш Х. Используем метод getPosition
        int pos = getPosition(x);

        /*После этого, так как наш Х преобразуется в двоичное число в нормальном виде, а нам нужно понять какой бит нам нужно изменить на ноль,
          нам нужно определить сдвиг единичного байта в числе.
        Для этого используем метод getShift который вернёт нам двоичное число с единственным единичным битом в нужном месте.*/
        int converted_number = getShift(x);

        //После этого мы инвертируем данное двоичное число и используя побитовое умножение И и найденную нами позицию удалим бит из множества
        this.set[pos + this.zeroIndex] &= ~converted_number;
    }

    @Override
    // присваиваем множеству А множество В
    public MySet assign(MySet b) {

        //Проверим что А != B.
        if (this == ((SetArray) b)) return this;


        // Зададим новую переменную C класса Set с границами множества В
        SetArray C = new SetArray(((SetArray) b).min, ((SetArray) b).max);
        //  Скопируем все элементы B в это новое множество
        C.copyFrom(((SetArray) b));
        //присвоим его в А

        return C;
    }

    @Override
    public int min() {
        int i;
        //Заведём цикл, который будет длиться пока множество А не закончится.
        for (i = 0; i < this.set.length; i++) {
            // В цикле сравниваем каждый элемент с нулём и ищем первый элемент, который отличен от нуля, запоминаем индекс
            if (this.set[i] != 0) break;
        }
        //После цикла проверим, если наш индекс равен длине массива, то значит в множестве нет никаких значений. Возвращаем ошибку
        if (i == this.set.length) throw new NoSuchElementException("В множестве нет чисел");

        /*Если всё-таки нашли какой-то диапазон со значениями, то заводим новую переменную типа int, которая равна минимальному числу в типе int.
    	  Это как раз единица в 32 бите числа из 32 битов*/
        int x = Integer.MIN_VALUE;
        int j;
        //Далее заводим цикл, который будет длиться пока не закончится набор битов в нужном диапазоне.
        for (j = 0; j < 31; j++) {
            //Используя логическое умножение будем умножать нашу переменную-минимум на элемент массива и будем проверять не равен ли результат нулю

            //Если результат отличен от нуля, значит мы нашли бит, который соответствует биту минимального числа
            //Иначе побитого сдвигаем наш минимум на один бит вправо
            if ((this.set[i] & x) != 0) break;
            x >>= 1;
        }
        //После выхода из цикла проверим не равен ли счётчик цикла 32. Если равен, то мы возвращаем ошибку.
        if (j == 32) throw new NoSuchElementException("Нет минимума");

        //Иначе преобразуем наше битовое представление числа-минимума в нормальный вид числа
        // (32 * {индекс найденной ячейки} + {индекс бита в битовом представлении} + zeroIndex * (-32)) и вернём его.
        return 32 * i + j + this.zeroIndex * (-32);
    }

    @Override
    public int max() {
        //Заведём цикл, который будет длиться пока множество А не закончится, но счётчик запустим от максимума к минимуму, то есть переберём с конца множества.
        int i;
        for (i = this.set.length - 1; i >= 0; i--) {
            //В цикле сравниваем каждый элемент с нулём и ищем первый элемент, который отличен от нуля, запоминаем индекс.
            if (set[i] != 0) break;
        }

        //После цикла проверим, если наш индекс равен -1, то значит в множестве нет никаких значений. Возвращаем ошибку.
        if (i == -1) throw new NoSuchElementException("В множестве нет чисел");


        //Если всё-таки нашли какой-то диапазон со значениями, то заводим новую переменную типа int которая равна единице, то есть занят только первый бит из 32.
        int x = 1;
        int j;
        //Далее заводим цикл, который будет длиться пока набор битов из ячейки не закончится, чтобы побитого пройтись по диапазону.
        for (j = 31; j >= 0; j--) {
            //Используя логическое умножение будем умножать нашу переменную-максимум на элемент массива и будем проверять не равен ли результат нулю.
            //Если результат отличен от нуля, значит мы нашли бит, который соответствует биту максимального числа.
            if ((this.set[i] & x) != 0) break;
            //Иначе побитого сдвигаем наш минимум на один бит вправо
            x <<= 1;
        }
        //После выхода из цикла проверим не равен ли счётчик цикла -1. Если равен, то мы возвращаем ошибку
        if (j == -1) throw new NoSuchElementException("Нет максимума");

        //Иначе преобразуем наше битовое представление в нормальный вид числа и вернём его
        return 32 * i + j + zeroIndex * (-32);
    }

    @Override
    // эквивалентность множества А и В
    public boolean equal(MySet b) {
        //Нам нужно определить смещение множество A относительно множества B.
        //Вычисляем смещение множества А относительно множества B.
        //Находим модуль разности А.zeroIndex и B.zeroIndex
        int shiftA = Math.abs(this.zeroIndex - ((SetArray) b).zeroIndex);

        int i;
        //Если у А смещение относительно глобального нуля больше чем у В, то нужно проверить что вне общих границ элементы А равны нулю
        if (this.zeroIndex > ((SetArray) b).zeroIndex) {
            //Заведём цикл, который будет идти ровно (найденное смещение) итераций
            for (i = 0; i < shiftA; i++)
                //Если какой-то из элементов не равен нулю, то возвращаем false
                if (this.set[i] != 0) return false;

            //Заведём цикл, который будет длиться пока не закончится общий участок множеств
            for (i = 0; i + shiftA < this.set.length && i < ((SetArray) b).set.length; i++)
                //Если соответствующие элементы не равны, то возвращаем false
                if (this.set[i + shiftA] != ((SetArray) b).set[i]) return false;
        } else { //Иначе если у В смещение больше чем у А, то нужно проверить что вне общих границ элементы В равны нулю.
            //Заведем цикл, который будет идти ровно (найденное смещение) итераций
            for (i = 0; i < shiftA; i++)
                //Если какой-то из элементов не равен нулю, то возвращаем false
                if (((SetArray) b).set[i] != 0) return false;
            //Заведём цикл, который будет длиться не закончится общий участок множеств
            for (i = 0; i < this.set.length && i + shiftA < ((SetArray) b).set.length; i++)
                //Если соответствующие элементы не равны, то возвращаем false
                if (this.set[i] != ((SetArray) b).set[i + shiftA]) return false;
        }

        //Теперь нужно проверить правый край множеств

        //Если правая граница множества А больше чем граница В
        i++;
        if (this.max > ((SetArray) b).max) {
            //Заведём цикл, который будет идти пока индекс меньше длинны множества А
            for (; i < this.set.length; i++)
                //Если элемент отличен от нуля, то возвращаем false
                if (this.set[i] != 0) return false;
        } else { //Если правая граница множества А меньше чем граница В.
            //Заведём цикл, который будет идти пока индекс меньше длинны множества В
            for (; i < ((SetArray) b).set.length; i++)
                //Если элемент отличен от нуля, то возвращаем false
                if (((SetArray) b).set[i] != 0) return false;
        }
        //Если мы дошли до этого момента, то возвращаем true
        return true;
    }

    @Override
    // поиск атома х в непересекающихся множествах А и В
    public MySet find(MySet b, int x) {

        //Используя метод getPosition найдём в каком диапазоне должен располагаться данный элемент
        int pos = getPosition(x);
        //Далее мы можем прибавить к найденному значению наш zeroIndex, чтобы обратится к нужному элементу множества А или множества В

        //Преобразуем число Х в битовое представление используя метод getShift
        int converted_number = getShift(x);

        /*Если логическое умножение битового представления элемента с индексом, который мы нашли ранее,
    	 в множестве А и битового представления Х отлично от нуля,
    	  значит Х находится в данном диапазоне множества А.*/
        if ((x >= this.min && x <= this.max) && (set[pos + zeroIndex] & converted_number) != 0)
            //Возвращаем множество А
            return this;

        /*Если логическое умножение битового представления элемента с индексом, который мы нашли ранее,
                в множестве В и битового представления Х отлично от нуля, значит Х находится в данном диапазоне множества В*/
        else if ((x >= ((SetArray) b).min || x <= ((SetArray) b).max) && (((SetArray) b).set[pos + ((SetArray) b).zeroIndex] & converted_number) != 0)
            //Возвращаем множество В
            return ((SetArray) b);

        //Если не нашли в обоих множествах, то возвращаем null
        return null;
    }
}

