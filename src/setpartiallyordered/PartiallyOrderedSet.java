package setpartiallyordered;

public class PartiallyOrderedSet {
    private class Trail {
        Atom id; //связный элемент
        Trail next; // ссылка на следующее отношение

        private Trail(Atom id, Trail next) {
            this.id = id;
            this.next = next;
        }
    }

    private class Atom extends Trail {
        int key; //Значение узла
        int count; // количество предшественников
        Atom nextElement; // Следующий элемент в цепочке

        private Atom(int value) {
            super(null, null); //Вызываем конструктор Trail
            this.key = value; //Задаём значение узла
            this.count = 0; //Укажем 0, так как это первый и единственный пока что элемент.
        }
    }

    Atom head;

    public PartiallyOrderedSet() {
        head = null;
    }

    //Метод для добавления новой пары в множество
    private void add(int[] pair) {

        //Создадим переменную типа Atom[] и присвоим ей значение метода search.
        Atom[] temp = search(pair);
        Atom tail = null; // Переменная, которая нужна на тот случай, если у нас ни один из элементов не присутствует в множестве
        //Проверим результат поиска.
        //Если значение узла не равно тому, которое мы искали, значит такого элемента нет в списке.
        if (temp[0].key != pair[0]) {
            // создадим новый атом и укажем его как следующий элемент после найденного нами в search, то есть последнего в множестве
            temp[0].nextElement = new Atom(pair[0]);
            //запомним наш новый Atom.
            temp[0] = temp[0].nextElement;
            tail = temp[0]; // Сохраним новый последний элемент
        }

        //Если значение узла не равно тому, которое мы искали,
        if (temp[1].key != pair[1]) {
            // Проверим не был ли обновлён последний элемент в множестве
            if (tail == null) {
                //Если не обновился, то создадим новый атом и укажем его как следующий элемент
                // после найденного нами в search, то есть последнего в цепочке
                temp[1].nextElement = new Atom(pair[1]);
                //запомним наш новый Atom.
                temp[1] = temp[1].nextElement;
            } else {
                // Если обновился, то создадим новый атом и укажем его как следующий элемент после
                //  обновлённого нами последнего элемента
                tail.nextElement = new Atom(pair[1]);
                //запомним наш новый Atom.
                temp[1] = tail.nextElement;
            }
        }
        //Обновим у второго элемента счётчик вхождений
        temp[1].count++;
        Trail tmp = null; // Создадим переменную в которую сохраним trail если он уже есть
        if (temp[0].id != null) { // Если у элемента уже есть связки на другие элемента,
            // то сохраним первый trail из цепочки.
            tmp = new Trail(temp[0].id, temp[0].next);
        }
        //Вставляем в первый trail новый Atom
        temp[0].id = temp[1];
        //Обновляем .next на наш tmp, который либо ссылка на уже существующий trail или null
        temp[0].next = tmp;
    }

    //Метод, который инициализирует множество
    public boolean init(int[][] array) {

        //Проверим:
        //Если первая пара не удовлетворяет условию иррефлексивности, то возвращаем false.
        if (array.length == 0 || array[0][0] == array[0][1])
            return false;

        //Начнём процесс инициализации.
        //Для начала возьмём первую пару.
        //Создадим новый Atom со значением первого элемента из первой пары (array[0][0]). Присвоим его в head.
        head = new Atom(array[0][0]);
        /*Далее создадим новый Atom со значением второго элемента из первой пары (array[0][0]).
        Присвоим его в id traila тем самым создадим связь между элементами.*/
        head.id = new Atom(array[0][1]);
        //Укажем в nextElement новый элемент
        head.nextElement = head.id;
        // и обновим количество предшествующих элементов.
        head.id.count++;

        //В цикле пройдёмся по оставшимся парам из array.
        for (int i = 1; i < array.length; i++) {
            //Если пара не удовлетворяет условию иррефлексивности, то возвращаем false.
            if (array[i][0] == array[i][1]) {
                return false;
            }
            //вызываем метод add для добавления новой пары
            add(array[i]);

        }
        //После цикла вернём true как сигнал об успешном ините.
        return true;
    }


    //Метод для поиска элемента множества с count = 0
    private Atom findZero() {
        //Создадим переменную Atom item для перебора элементов в множестве, начиная со второго элемента.
        Atom item = head.nextElement;
        //Создадим переменную Atom prev для того, чтобы вернуть найденный нами предыдущий элемент. Изначально значение head
        Atom prev = head;

        //Пока множество не закончится, будем перебирать его
        while (item != null) {
            //Проверим не нашли ли мы элемент, у которого нет предшествующих элементов.
            if (item.count == 0) {
                //Если нашли, то возвращаем предыдущий элемент.
                return prev;
            }
            //Иначе обновим итератор и сохраним предыдущий элемент.
            prev = item;
            item = item.nextElement;
        }
        //Если ничего не нашли, возвращаем null
        return null;
    }

    //Метод для сортировки множества
    public boolean sort() {

        // Проверка на возможность сортировки по значению count
        if (head == null || head.count != 0) {
            System.out.println("Множество не может быть отсортировано.");
            System.exit(1); // Завершаем программу с кодом ошибки 1
            return false; // Множество не может быть отсортировано
        }

        //Переменная для головы нового, сортированного множества
        Atom newHead = null;
        Atom last = null; // Переменная, которая будет хранить последний из элементов в сортированном множестве

        //Пока элементы не закончатся
        while (head != null) {

            //Проверим первый элемент из множества
            //Если у головы счётчик вхождений равен нулю, то нам подходит
            if (head.count == 0) {
                //Проверим создано ли уже сортированное множество
                if (newHead == null) {
                    //Если нет, то создаём новый элемент со значением key первого элемента и присваиваем его в голову
                    //нового сортированного множества
                    newHead = new Atom(head.key);
                    //Запишем этот элемент как последний в множестве
                    last = newHead;
                } else {
                    //Если уже начали собирать множество, то присвоим Atom head как следующий элемент после last и обновим last
                    last.nextElement = head;
                    last = last.nextElement;
                }
                //Обновляем счётчик у элементов множества перед удалением элемента
                updateCount(head);
                //Обновляем голову на следующий элемент
                head = head.nextElement;
                continue;
            }
            //Если голова не подходит, то вызываем метод поиска элемента с count = 0
            Atom result = findZero();

            //Проверим результат. Если результат равен null, то у нас нет элемента с count 0
            if (result == null) {
                //Делаем return false
                return false;
            }

            //Иначе мы нашли элемент, который стоит перед нужным нам
            //Проверим создано ли уже сортированное множество
            if (newHead == null) {
                //Если нет, то создаём новый элемент со значением key следующего элемента после найденного и присваиваем его в голову
                //нового сортированного множества
                newHead = new Atom(result.nextElement.id.key);
                //Запишем этот элемент как последний в множестве
                last = newHead;
            } else {
                //Если уже начали собирать множество, то присвоим Atom head как следующий элемент после last и обновим last
                last.nextElement = result.nextElement;
                last = last.nextElement;
            }
            //Обновляем счётчик у элементов множества перед удалением элемента
            updateCount(result.nextElement);
            //Обновляем голову на следующий элемент
            result.nextElement = result.nextElement.nextElement;
        }
        // Обновим голову на новую
        head = newHead;
        //Возвращаем true как успех
        return true;
    }

    //Метод для обновления счётчиков у связных элементов.
    private void updateCount(Atom item) {
        Trail trail = item;
        if (item.id == null) {
            trail = null;
        }

        //пока элементы в отношении не закончились
        while (trail != null) {
            //будем уменьшать у элементов счётчик вхождений на 1.
            trail.id.count--;
            //И сдвигаем итератор на следующее отношение.
            trail = trail.next;
        }

    }


    //Метод для поиска элементов пары в множестве
    private Atom[] search(int[] p) {
        Atom[] res = new Atom[2];
        //Создадим переменную Atom в которую присвоим head
        Atom q = head;
        //Создадим новую переменную класса Atom. Она нужна нам, чтобы запомнить предыдущий элемент.
        Atom q2 = null;

        //В цикле пока не закончатся элементы в множестве.
        while (q != null) {

            //Если у нас нашлось совпадение, то есть элемент есть в множестве, то возвращаем его.
            if (p[0] == q.key) {
                res[0] = q;
            } else if (p[1] == q.key) {
                res[1] = q;
            }
            if (res[0] != null && res[1] != null)
                return res;
            //Если нет, то запоминаем предыдущий элемент и сдвигаем итератор на следующий.
            q2 = q;
            q = q.nextElement;
        }
        // Если мы не вернули элементы из цикла, значит в множестве нет такого значения. Возвращаем последний элемент из множества.
        if (res[0] == null) res[0] = q2;
        if (res[1] == null) res[1] = q2;
        return res;
    }


    public void print() {
        Atom item = head;
        System.out.print(item.key);
        item = item.nextElement;
        while (item != null) {
            System.out.print(" < " + item.key);
            item = item.nextElement;
        }
        System.out.println();
    }
}
