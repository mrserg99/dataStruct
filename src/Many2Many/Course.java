package Many2Many; //Подключаем пакет для работы с ManyToMany

public class Course {
    CourseElement[] array; // массив курсов

    //Конструктор для создания массива курсов
    public Course(int a) {
        //присваиваем переменной array созданный пустой массив курсов
        array = new CourseElement[a];
    }

    //Определим метод, который будет возвращать хэш от номера курса
    private int hash(int n) {
        return n % array.length;
    }

    //Метод добавления курса в массив курсов
    public void insert(int n) {
        // Найдём значение hash функции от номера курса
        int key = hash(n);
        int j = 0;

        //Проверим есть ли значение по такому ключу
        if (array[key] == null) {
            // Если нет, то создаём новые элемент курса с присланным номером
            array[key] = new CourseElement(n, null);
        }
        //Иначе если по такому ключу уже есть значение, то проверим не равно ли оно нужному нам курсу
        else if (array[key].course == n) {
            //Если совпадает, то добавлять ничего не нужно. Делаем return
            return;
        }
        //Проверим не удалено ли значение ячейки. Если удалено, то установим новое имя
        else if (array[key].course == 0) {
            array[key].course = n;
        }
        //Иначе
        else {
            //Иначе уже есть значения по данному хэшу. Нужно получить уникальный хэш.
            //Получим ключ увеличив предыдущий хэш на 1
            int newKey = hash(n + 1);
            //В цикле, пока хэш не повторится, будем искать первое пустое место по новому хэшу
            while (newKey != key) {
                //Если по новому хэшу нет значений, то записываем наш курс
                if (array[newKey] == null) {
                    array[newKey] = new CourseElement(n, null);
                    return;
                }
                //если место уже занято, то проверим не занято ли оно уже нужным нам номером курса.
                else if (array[newKey].course == n) {
                    //Если совпадает, то добавлять ничего не нужно. Делаем return
                    return;
                }
                //Проверим не удалено ли значение ячейки. Если удалено, то установим новое имя
                else if (array[newKey].course == 0) {
                    array[newKey].course = n;
                    return;
                }
                //Если по новому ключу уже есть какое-то значение, которое не удовлетворяет требованиям, то обновляем ключ
                newKey = hash(n + 1);
            }
        }
    }


    //Метод определяет есть ли номер курса в списке курсов.
    public CourseElement member(int n) {
        //Ищем есть ли такой элемент в массиве. Метод search
        int key = search(n);
        //Если ключ отличен от -1, то возвращаешь элемент курса по этому ключу.
        if (key != -1) return array[key];
            //иначе возвращаем null
        else return null;
    }

    //Метод возвращает список курсов
    public void print() {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i].course + " ");
        }
        System.out.println();
    }

    //Метод позволяет найти ключ, по которому расположен нужный номер курса.
    private int search(int n) {
        //Определяем хэш значение от номера курса
        int key = hash(n);
        int j = 0;
        //Проверяем значение, которое лежит по этому курсу.
        //Если значение равно присланному курсу, то возвращаем этот ключ
        if (array[key] != null && array[key].course == n) return key;
        //Иначе запоминаем это ключ, как стартовое значение
        int start = key;
        //И обновляем ключ на следующий
        key = hash(n + 1);
        //Пока ключи не пойдут по второму кругу и значение по ключу не будет равно null
        while (array[key] != null && key != start) {
            //Будем сравнивать значение по ключу с нужным нам
            if (array[key].course == n) {
                //Если совпало, то возвращаем найденный ключ
                return key;
            }
            //Иначе обновляем ключ на новый
            key = hash(n + 1);
        }
        //Если не вернули ключ, значит значения в массиве нет. Возвращаем -1.
        return -1;
    }
}